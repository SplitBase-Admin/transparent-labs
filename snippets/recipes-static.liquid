{% comment %}

This file is controlled by the Recipes app by BentoSMB.

-----------------------------------------------------------------------------
-------- DO NOT UPDATE THIS FILE DIRECTLY - ALL CHANGES WILL BE LOST --------
-----------------------------------------------------------------------------

{% endcomment %}

{%- comment -%}
  1) Collect any recipe placeholders we can see server-side (page/article/product description).
     This lets us pre-render corresponding recipe HTML once, then JS can clone as needed.
{%- endcomment -%}
{% assign _raw_source = "" %}
{% assign _has_placeholders = false %}

{% if template.name == 'page' and page.content contains '[[ recipeID=' %}
    {% assign _raw_source = page.content %}
    {% assign _has_placeholders = true %}
{% elsif template.name == 'article' and article.content contains '[[ recipeID=' %}
    {% assign _raw_source = article.content %}
    {% assign _has_placeholders = true %}
{% elsif template.name == 'product' and product.description contains '[[ recipeID=' %}
    {% assign _raw_source = product.description %}
    {% assign _has_placeholders = true %}
{% endif %}

{%- comment -%}
  2) Extract unique recipe IDs from the raw source if present.
     We split on the token and grab up to the first comma or closing brackets.
{%- endcomment -%}
{% assign recipe_ids_csv = "" %}
{% if _has_placeholders %}
    {% assign tokens = _raw_source | split: '[[ recipeID=' %}
    {% for t in tokens %}
        {% if forloop.first %}{% continue %}{% endif %}
        {% assign tail = t | split: ']]' | first %}
        {% assign id_candidate = tail | split: ',' | first | strip | strip_html %}
        {% unless recipe_ids_csv contains id_candidate %}
            {% assign recipe_ids_csv = recipe_ids_csv | append: id_candidate | append: ',' %}
        {% endunless %}
    {% endfor %}
{% endif %}
{% assign recipe_ids = recipe_ids_csv | split: ',' | uniq %}

{%- comment -%}
  3) Pre-render any recipes we discovered into a hidden template bank.
     JavaScript will pull from here by data-recipeid.
{%- endcomment -%}
<div id="recipes-templates" hidden aria-hidden="true" style="display:none">
    {% for rid in recipe_ids %}
        {% if rid != blank %}
            <template class="recipe-template" data-recipeid="{{ rid | escape }}">
                {% render 'recipe-single', recipeID: rid %}
            </template>
        {% endif %}
    {% endfor %}
</div>

{%- comment -%}
  4) Client: Replace all occurrences of [[ recipeID=... ]] anywhere on the page.
     - Safe text-node replacement (no innerHTML blast)
     - Works for late-added content (MutationObserver)
     - Dedup via cloning pre-rendered templates
     - Optional attribute parsing: [[ recipeID=abc, view=card, size=compact ]]
{%- endcomment -%}
<script>
    (() => {
        // =========================
        // Configuration & Constants
        // =========================

        /** Matches placeholders like:
         *  [[ recipeID=my-recipe-123, view=card, size=compact ]]
         *  Captures:
         *    group 1: recipe ID
         *    group 2: raw attributes string (optional)
         */
        const PLACEHOLDER_RE = /\[\[\s*recipeID\s*=\s*([A-Za-z0-9_\-:]+)(?:\s*,\s*([^\]]+))?\s*\]\]/g;

        // Elements we never parse inside
        const DISALLOWED_CONTAINERS = new Set(['SCRIPT', 'STYLE', 'TEXTAREA', 'NOSCRIPT', 'TEMPLATE']);

        // =========================
        // Small, Focused Utilities
        // =========================

        /**
         * Convert "key=value, key2=value2" into { key: "value", key2: "value2" }.
         * Trims whitespace; ignores empty pairs.
         */
        function parseAttributeList(raw) {
            if (!raw) return {};
            const out = {};
            raw.split(',').forEach((pair) => {
                const [k, v] = pair.split('=');
                if (!k) return;
                out[k.trim()] = (v || '').trim();
            });
            return out;
        }

        /** Returns true if the text node lives inside an element we should skip. */
        function isInsideDisallowed(node) {
            for (let el = node.parentNode; el; el = el.parentNode) {
                if (el.nodeType !== 1) continue;
                if (DISALLOWED_CONTAINERS.has(el.nodeName)) return true;
                if (el.hasAttribute?.('data-recipe-processed')) return true; // avoid recursion
            }
            return false;
        }

        // =========================
        // Template Bank (cache)
        // =========================

        /**
         * Build a Map of recipeId -> <template> node from the hidden template bank.
         */
        function createTemplateMap() {
            const bank = document.getElementById('recipes-templates');
            const map = new Map();
            if (!bank) return map;
            bank.querySelectorAll('.recipe-template[data-recipeid]').forEach((tpl) => {
                map.set(tpl.getAttribute('data-recipeid'), tpl);
            });
            return map;
        }

        /**
         * Given an ID and optional attributes, return a DOM node for insertion.
         * Prefers cloning a pre-rendered template; otherwise emits a readable fallback.
         */
        function buildRecipeNode(recipeId, attrs, templateMap) {
            const tpl = templateMap.get(recipeId);
            if (tpl) {
                const fragment = tpl.content.cloneNode(true);
                const wrapper = document.createElement('div');
                wrapper.className = 'recipe-container';
                wrapper.setAttribute('data-recipeid', recipeId);
                wrapper.setAttribute('data-recipe-processed', '1');
                if (attrs && typeof attrs === 'object') {
                    for (const [k, v] of Object.entries(attrs)) {
                        wrapper.setAttribute(`data-${k}`, v);
                    }
                }
                wrapper.appendChild(fragment);
                return wrapper;
            }

            // Graceful fallback if we didnâ€™t pre-render this ID server-side.
            const missing = document.createElement('div');
            missing.className = 'recipe-container recipe-missing';
            missing.setAttribute('data-recipeid', recipeId);
            missing.setAttribute('data-recipe-processed', '1');
            missing.textContent = `Recipe "${recipeId}" not found in templates.`;
            return missing;
        }

        // =========================
        // Replacement Engine
        // =========================

        /**
         * Scan a single TEXT node and replace all placeholders within it.
         * Returns true if any replacement occurred.
         */
        function replacePlaceholdersInTextNode(textNode, templateMap) {
            const text = textNode.nodeValue;
            if (!text || text.indexOf('[[') === -1) return false; // quick reject

            let match;
            let lastIndex = 0;
            let changed = false;
            PLACEHOLDER_RE.lastIndex = 0;

            const frag = document.createDocumentFragment();

            while ((match = PLACEHOLDER_RE.exec(text)) !== null) {
                changed = true;

                // 1) Append literal text before the match
                const before = text.slice(lastIndex, match.index);
                if (before) frag.appendChild(document.createTextNode(before));

                // 2) Build and append the recipe node
                const recipeId = match[1];
                const attrs = parseAttributeList(match[2]);
                frag.appendChild(buildRecipeNode(recipeId, attrs, templateMap));

                // 3) Advance cursor
                lastIndex = match.index + match[0].length;
            }

            if (!changed) return false;

            // Append trailing text (after last match)
            const after = text.slice(lastIndex);
            if (after) frag.appendChild(document.createTextNode(after));

            // Replace the original text node once
            textNode.replaceWith(frag);
            return true;
        }

        /**
         * Walk a subtree and attempt replacements in text nodes only.
         * Safe for event handlers / state on existing elements.
         */
        function processSubtree(root, templateMap) {
            try {
                const walker = document.createTreeWalker(
                    root,
                    NodeFilter.SHOW_TEXT,
                    {
                        acceptNode: (n) => {
                            if (isInsideDisallowed(n)) return NodeFilter.FILTER_REJECT;
                            // Quick scan to skip nodes without our token
                            return (n.nodeValue && n.nodeValue.includes('[['))
                                ? NodeFilter.FILTER_ACCEPT
                                : NodeFilter.FILTER_REJECT;
                        }
                    }
                );

                const nodes = [];
                for (let n = walker.nextNode(); n; n = walker.nextNode()) nodes.push(n);
                nodes.forEach((tn) => replacePlaceholdersInTextNode(tn, templateMap));
            } catch (err) {
                console.warn('Recipes: replacement error', err);
            }
        }

        // =========================
        // Boot & Observe
        // =========================

        const templateMap = createTemplateMap();

        // Initial pass (whole page)
        const runInitial = () => processSubtree(document.body, templateMap);
        (document.readyState === 'loading')
            ? document.addEventListener('DOMContentLoaded', runInitial)
            : runInitial();

        // Keep working for dynamically-inserted content (sections, app blocks, modals)
        const observer = new MutationObserver((mutations) => {
            for (const m of mutations) {
                // Elements added
                for (const node of m.addedNodes) {
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        processSubtree(node, templateMap);
                    } else if (node.nodeType === Node.TEXT_NODE) {
                        if (!isInsideDisallowed(node)) replacePlaceholdersInTextNode(node, templateMap);
                    }
                }
            }
        });

        observer.observe(document.documentElement, { childList: true, subtree: true });
    })();
</script>
